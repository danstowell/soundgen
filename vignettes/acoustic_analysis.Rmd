---
title: "Acoustic analysis with soundgen"
author: "Andrey Anikin"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 4
vignette: >
  %\VignetteIndexEntry{Acoustic analysis with soundgen}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# Purpose

There are numerous programs out there for performing acoustic analysis, including several open-source options and R packages. For in-depth analysis of individual mammalian sounds it's hard to beat <a href="http://www.fon.hum.uva.nl/praat/">PRAAT</a> (batch processing is possible, but a bit tricky, because PRAAT uses its own, rather unusual scripting language). For bird sounds, a sophisticated tool is <a href="http://soundanalysispro.com/">Sound Analysis Pro</a>. In R, the most extensive toolkit by far is the <a href="https://cran.r-project.org/web/packages/seewave/index.html">seewave</a> package. Soundgen builds upon the functionality of seewave, adding specialized functions for sound synthesis (see the vignette on sound synthesis) and acoustic analysis, particularly pitch tracking and audio segmentation.

Reasons to use `soundgen` for acoustic analysis might be: 

1. User-friendly approach: a single call to the `analyzeFolder` function will give you a dataframe containing dozens of commonly used acoustic descriptors for each file in an entire folder. So if you'd rather get started with model-building without delving too deeply into acoustics, you are one line of code away from your dataset.
1. Flexible pitch tracking: soundgen uses several popular methods of pitch detection in parallel, followed by their integration and postprocessing. While the abundance of parameters may initially seem daunting, for those who do wish to delve deeply this makes soundgen's pitch tracker very versatile and offers a lot of power for high-precision analysis.
1. Audio segmentation with in-built optimization: the tools for syllable segmentation are again very flexible. Control parameters can even be optimized automatically, as long as you have a manually segmented training sample.

To summarize, you might want to look at soundgen's tools for acoustic analysis if you are extracting a large number of acoustic predictors from a large number of audio files, for example:

* describing the vocal repertoire of a species (clustering),
* using machine learning for acoustic classification,
* comparing different classes of sounds in terms of specific acoustic predictors.

The most relevant functions are:

* `analyze`: analyzes a single sound and extracts a number of acoustic predictors such as pitch, harmonics-to-noise ratio, mean frequency, peak frequency, etc. The output can be a summary per file, with each variable presented as mean / median / SD, or you can obtain detailed statistics per FFT frame.
* `analyzeFolder`: same as `analyze` but applied to all .wav files in a folder
* `segment`: finds syllables and bursts of energy in a single sound using its amplitude envelope
* `segmentFolder`: same as `segment` but applied to all .wav files in a folder
* `optimizePars`: optimizes control parameters of `segment` or `analyze` aiming to reproduce manual segmentation of a training sample
* `ssm`: produces a self-similarity matrix and calculates novelty as an alternative method of audio segmentation

*TIP Soundgen's functions for acoustic analysis are not meant to be exhaustive. MFCC extraction is readily available in R with `tuneR::melfcc`, so there was no need to include it in soundgen. LPC is also implemented in R (see `phonTools::lpc` and `phonTools::findformants`), but, to be perfectly honest, for serious formant analysis I would actually recommend using PRAAT and checking everything manually. You can thus start with `soundgen::analyze` to get a table of many common acoustic predictors and then add some more using other R packages and/or other software or manual measurements, or you could customize `soundgen::analyze` to extract additional predictors.*

This vignette is designed to show how soundgen can be used effectively to perform acoustic analysis. It assumes that the reader is already familiar with key concepts of phonetics and bioacoustics. In case some parts of the presentation seem obscure, helpful sources for further reading are suggested below in References. 

# Acoustic analysis with `analyze`
To demonstrate acoustic analysis in practice, let's begin by generating a sound with known pitch. To make pitch tracking less trivial and demonstrate some of the challenges, let's add some noise, subharmonics, and jitter:
```{r}
library(soundgen)
s = soundgen(sylLen = 900, temperature = 0,
             pitchAnchors = list(time = c(0, .3, .8, 1), value = c(300, 900, 400, 2300)),
             noiseAnchors = list(time = c(0, 900), value = c(-40, 20)),
             subDep = 100, jitterDep = 0.5, pitchEffects_amount = 100)
# playme(s)  # replay as many times as needed w/o re-synthesizing the sound
```

The contour of F0 is determined by our pitchAnchors, so we can calculate its true median pitch:
```{r}
true_pitch = getSmoothContour(anchors = list(time = c(0, .3, .8, 1),
                                             value = c(300, 900, 400, 2300)), 
                              len = 1000)  # any length will do
# median(true_pitch)  # 611 Hz
```


## Basic principles
At the heart of acoustic analysis with soundgen is the Short-time Fourier Transform (STFT): we look at one short segment of sound at a time (one FFT frame), analyze its spectrum using Fast Fourier Transform (FFT), and then move on to the next - perhaps overlapping - frame. As the analysis window slides along the signal, STFT shows which frequencies it contains at different points of time. The nuts and bolts of STFT are beyond the scope of this vignette, but they can be found in just about any textbook on phonetics, acoustics, digital signal processing, etc. For a quick R-friendly introduction, see <a href="https://cran.r-project.org/web/packages/seewave/vignettes/seewave_analysis.pdf">seewave vignette</a>. 
Putting the spectra of all frames together, we get a spectrogram. `analyze` calls another function from soundgen package, `spec`, to produce a spectrogram and then plot pitch candidates on top of it. `spec` is a modified version of `seewave::spectro` with added routines for removing background noise, controlling contrast and brightness, adding median smoothing, etc (see the examples in `?soundgen::spec`). To analyze a sound with default settings and plot its spectrogram, all we need to specify is its sampling rate (the default in soundgen is 16000 Hz):

```{r fig.show = "hold", fig.height = 5, fig.width = 7}
a1 = analyze(s, samplingRate = 16000, plot = TRUE)
# summary(a1)  # many acoustic predictors measured for each FFT frame
median(true_pitch)  # true value, as synthesized above
median(a1$pitch, na.rm = TRUE)  # our estimate: way off, mainly b/c of misleading subharmonics
```

There are several key parameters that control the behavior of STFT and affect all extracted acoustic variables. The same parameters serve as arguments to `spec` and control the spectrogram. As a result, you can immediately see what frame-by-frame input you have fed into the algorithm for acoustic analysis by visually inspecting the produced spectrogram. If you can hear F0, but can't see individual harmonics in the spectrogram, the pitch tracker probably will not see them, either, and will therefore fail to detect F0 correctly. The first remedy to try is to adjust STFT settings, using the spectrogram for visual feedback:

* `windowLength`: the length of sliding STFT window. Longer windows (e.g., 40 - 50 ms) improve frequency resolution at the expense of time resolution, so they are good for detecting relatively low, slowly changing F0, as in human moans or grunts. Shorter windows (e.g., 5 - 10 ms) improve time resolution at the expense of frequency resolution, so they are good for visualizing formants or detecting high, rapidly changing F0 as in bird chirps or sweeping mammalian whistles.
* `step`: the step of sliding STFT window. For example, if `windowLength = 50` and `step = 25`, each time we move the analysis frame, there is a 50% overlap with the previous frame. This introduces redundancy into the analysis, but it also - to some limited extent - improves time resolution while maintaining relatively high frequency resolution. The main cost of small steps (large overlap) is processing time, but very large overlap is not always desirable, even when processing time is not an issue. If some audio segments are problematic (e.g., very noisy), pitch contour may actually be more accurate with relatively large steps and more smoothing. It is therefore best to check the results with different steps and/or run formal optimization (remember to adjust smoothing and other postprocessing parameters together with STFT settings).
* `wn`: the type of windowing function used to taper the analysis frame during STFT. In practice the windowing function doesn't seem to have a major effect on the result, as long as you choose something reasonable like gaussian, hanning, or bartlett. 
* `zp`: zero-padding. You can use a short STFT window and improve its frequency resolution by padding each frame with zeroes. This is a computational trick that - again, to some limited extent - improves frequency resolution while maintaining relatively high time resolution. 
* `silence`: frames with amplitude below silence threshold are not analyzed at all. Quiet frames are harder to analyze, because their signal-to-noise ratio is lower. As a result, we want to strike a good balance. Setting `silence` too low (close to 0) produces a lot of garbage, as the algorithm tries to analyze frames that are essentially just background noise without any signal. Setting `silence` too high (close to 1) excludes too many perfectly good frames, misrepresenting the signal. In soundgen `silence` is dynamically updated: it can never be lower than specified, but it may be raised to the minimum root mean square amplitude of all frames, if this minimum is higher than `silence`. This ensures that empty frames are not analyzed in recordings with high levels of steady background noise (e.g., microphone hiss).

## Basic spectral descriptives
Apart from pitch tracking, `analyze` calculates and returns several acoustic characteristics from each non-silent FFT frame:

* `time`: time stamp in middle of each frame (ms)
* `voiced`: is the current FFT frame voiced? TRUE / FALSE
* `ampl`: perceived intensity - root mean square of amplitude per frame, calculated as `sqrt(mean(frame ^ 2))`
* `ampl_voiced`: the same as `ampl` for voiced frames and `NA` for unvoiced frames
* `entropy`: Weiner entropy of the spectrum of the current frame. Close to 0: tonal; close to 1: white noise
* `HNR`: harmonics-to-noise ratio (dB), a measure of harmonicity returned by `soundgen:::getPitchAutocor` (see "Pitch tracking methods / Autocorrelation")
* `dom`: lowest dominant frequency band (Hz) (see "Pitch tracking methods / Dominant frequency")
* `meanFreq`: the center of gravity of the frame's spectrum, first spectral moment (Hz)
* `peakFreq`: the frequency with maximum spectral power (Hz)
* `peakFreq_cut`: the frequency with maximum spectral power below `cutoff_freq` (Hz)
* `quartile25`, `quartile50`, `quartile75`: the 25th, 50th, and 75th quantiles of the spectrum below `cutoff_freq` (Hz)
* `specSlope`: the slope of linear regression fit to the spectrum below `cutoff_freq`
* `harmonics`: the amount of energy in upper harmonics, namely the ratio of total spectral power above 1.25 x F0 to the total spectral power below 1.25 x F0 (dB)

## Pitch tracking
If you look at the source code of `soundgen::analyze`, you will see that almost all of it deals with a single acoustic characteristic: fundamental frequency (F0) or its perceptual equivalent, pitch. That's because pitch is both highly salient to listeners and notoriously difficult to measure accurately. Many of the large variety of existing pitch tracking algorithms were designed for analyzing a particular type of sound, usually human speech. Soundgen's pitch tracker was written to analyze human non-linguistic vocalizations like screams and laughs. These sounds are much harsher and noisier than ordinary speech. In addition, the original corpus (Anikin & Persson, 2017) was collected from online videos, so that both sampling rate and microphone settings varied tremendously. From the very beginning, the focus has thus been on developing a pitch tracker that would be robust to noise and recording conditions. 

The approach followed with soundgen's pitch tracker is to use several different estimates of the fundamental frequency, each of which is particularly suited to certain types of sounds. You can use any of them individually, but their output is also automatically integrated and postprocessed so as to generate the best overall estimate of frame-by-frame pitch. There are four currently implemented classes of pitch estimates in soundgen: autocorrelation, lowest dominant frequency, cepstrum, and BaNa. These four methods of pitch estimation are not treated as completely independent in soundgen. Autocorrelation is performed first to provide an initial guess at the likely pitch and harmonics-to-noise ratio (HNR) of an FFT frame, and then this information is used to adjust the expectations of the cepstral and spectral algorithms. In particular, if autocorrelation suggests that the pitch is high, confidence in cepstral estimates is attenuated; and if autocorrelation suggests that HNR is low, thresholds for spectral peak detection are raised, making spectral pitch estimates more conservative. 

The plot below shows a spectrogram of the sound with overlaid pitch candidates: yellow circles = autocorrelation pitch estimate (`pitchAutocor`), red triangles = spectral pitch estimate (`pitchSpec`), orange crosses = lowest dominant frequency band (`dom`). The size of each point shows the certainty of estimation: smaller points are calculated with lower certainty and have less weight when all candidates are integrated into the final pitch contour (blue line). To specify which pitch tracking methods should be employed, use `pitch_methods`. For example, we can also include cepstral estimates (violet envelopes):
```{r fig.show = "hold", fig.height = 5, fig.width = 7}
a = analyze(s, samplingRate = 16000, plot = TRUE, 
            pitch_methods = c('autocor', 'cep', 'dom', 'spec'))
```

### General settings
`analyze` has a few arguments that affect all methods of pitch tracking:

* `entropy_threshold`: all non-silent frames are analyzed to produce basic spectral descriptives. However, pitch tracking is both computationally costly and can be misleading if applied to obviously voiceless frames. To define what an "obviously voiceless" frame is, we set some cutoff value of Weiner entropy, above which we don't want to even try pitch tracking. To disable this feature and track pitch in all non-silent frames, set `entropy_threshold` to 1.
* `pitch_floor`, `pitch_ceiling`: absolute thresholds for pitch candidates. No values outside these bounds will be considered.
* `prior_mean` and `prior_sd` specify the mean and sd of gamma distribution describing our prior knowledge about the most likely pitch values. The prior works by scaling the certainties associated with particular pitch candidates: candidates more than a couple of `prior_sd`'s from `prior_mean` have their weight reduced to nearly zero. Based on my limited testing, the mildly informative default prior in `analyze` does improve the accuracy of pitch tracking in human vocalizations. Prior values are specified in semitones above C0 (~16 Hz), and densities are calculated on a musical scale. For example, if we expect F0 values of about 300 Hz ± half an octave (6 semitones) up or down, a prior can be defined as `prior_mean = HzToSemitones(300), prior_sd = 6`. For convenience, the prior can be plotted directly from `analyze`:

```{r fig.show = "hold", fig.height = 5, fig.width = 7}
par(mfrow = c(1, 2))
# default prior in soundgen
a1 = analyze(s, samplingRate = 16000, plot = FALSE, prior_plot = TRUE,
             prior_mean = HzToSemitones(300), prior_sd = 6)  
# narrow peak at 2 kHz
a2 = analyze(s, samplingRate = 16000, plot = FALSE, prior_plot = TRUE,
             prior_mean = HzToSemitones(2000), prior_sd = 1)
par(mfrow = c(1, 1))
``` 
*TIP The final pitch contour can still pass through low-certainty candidates, especially if no better candidates are available. You can therefore think of the prior as a soft alternative (or addition) to `pitch_floor` and `pitch_ceiling`*

* `nCands`: maximum number of pitch candidates to use per method. This only affects `pitchAutocor`, `pitchCep`, and `pitchSpec`. `dom` never returns more than one candidate per frame, since it doesn't make sense to consider several lowest dominant frequency bands - this simply drags the final pitch contour upwards without improving the accuracy.
* `min_voiced_cands`: minimum number of pitch candidates that have to be defined to consider a frame voiced. It defaults to 'autom', which means 2 if `dom` is among the candidates and 1 otherwise. The reason is that `dom` is usually defined, even if the frame is clearly voiceless, so we want another pitch candidate in addition to `dom` before we classify the frame as voiced.

### Pitch tracking methods
Having looked at the general settings, it is time to consider the theoretical principles behind each pitch tracking method, together with arguments to `analyze` that can be used to tweak each one.
  
#### Autocorrelation
Time domain: pitch by autocorrelation, PRAAT, `pitchAutocor`.
  
This is an R implementation of the algorithm used in the popular open-source program PRAAT (Boersma, 1993). The basic idea is that a harmonic signal correlates with itself most strongly at a delay equal to the period of its fundamental frequency (F0). Peaks in the autocorrelation function are thus treated as potential pitch candidates. The main trick is to choose an appropriate windowing function and adjust for its own autocorrelation. Compared to other methods implemented in soundgen, pitch estimates based on autocorrelation appear to be particularly accurate for relatively high values of F0. The settings that control `pitchAutocor` are:
  
  * `autocor_threshold`: voicing threshold, defaults to 0.7. This means that peaks in the autocorrelation function have to be at least 0.7 in height (1 = perfect autocorrelation). Lower threshold values produces more false positives (F0 is detected in voiceless, noisy frames), whereas higher threshold produces more accurate values F0 at the expense of failing to detect F0 in noisier frames.
  * `autocor_smoothing`: the width of smoothing interval (in bins) for finding peaks in the autocorrelation function. If left NULL, it defaults to 7 for sampling rate 44100 and smaller odd numbers for lower sampling rate.
                   
To use only autocorrelation pitch tracking, but with lower voicing threshold and more candidates than the defaults, we can do something like this (prior is disabled so as not to influence the certainties of different pitch candidates):
```{r fig.show = "hold", fig.height = 5, fig.width = 7}
a = analyze(s, samplingRate = 16000, plot = TRUE, prior_mean = NA,
            pitch_methods = 'autocor',
            autocor_threshold = .3,
            nCands = 2)
```

#### Dominant frequency
Frequency domain: the lowest dominant frequency band, `dom`. 

If the sound is harmonic and relatively noise-free, the spectrum of a frame typically has little energy below F0. It is therefore likely that the first sizeable peak in the spectrum is in fact F0, and all we have to do is choose a reasonable threshold. Natually, there are cases of missing F0 and misleading low-frequency noises. Nevertheless, this simple estimate is often surprisingly accurate, and it may be our best shot when the vocal cords are vibrating in a chaotic fashion (deterministic chaos). For example, sounds such as roars lack clear harmonics but are perceived as voiced, and the lowest dominant frequency band often corresponds to perceived pitch. 
  
The settings that control `dom` are:
  
  * `dom_threshold` (defaults to 0.1, range 0 to 1): to find the lowest dominant frequency band, we look for the lowest frequency with amplitude at least `dom_threshold`. This key setting has to be high enough to exclude accidental low-frequency noises, but low enough not to miss F0. As a result, the optimal level depends a lot on the type of sound analyzed and recording conditions.
  * `dom_smoothing` (defaults to 220 Hz): the width of smoothing interval (Hz) for finding the lowest spectral peak. The idea is that we are less likely to hit upon some accidental spectral noise and find the lowest harmonic (or the lowest spectral band with significant power) if we apply some smoothing to the spectrum of an FFT frame. 
  
For the sound we are trying to analyze, we can increase `dom_smoothing` and/or raise `dom_threshold` to ignore the subharmonics and trace the true pitch contour:
  
```{r fig.show = "hold", fig.height = 5, fig.width = 7}
a = analyze(s, samplingRate = 16000, plot = TRUE, prior_mean = NA,
            pitch_methods = 'dom',
            dom_threshold = .3,
            dom_smoothing = 500)
```

#### Cepstrum
Frequency domain: pitch by cepstrum, `pitchCep`.

Cepstrum is the FFT of log-spectrum. It may be a bit challenging to wrap one's head around, but the main idea is quite simple: just as FFT is a way to find periodicity in a signal, cepstrum is a way to find periodicity in the spectrum. In other words, if the spectrum contains regularly spaced harmonics, its FFT will contain a peak corresponding to this regularity. And since the distance between harmonics equals the fundamental frequency, this cepstral peak gives us F0. Actually, in soundgen the FFT is applied to raw spectrum, not log-spectrum, since it appears to produce better results. Cepstrum is not very useful when F0 is so high that the spectrum contains only a few harmonics, so soundgen automatically discounts the contribution of high-frequency cepstral estimates. Cepstral pitch tracking is disabled by default, since this method is both slower and less robust for human non-linguistic vocalizations. Depending on the type of analyzed audio, however, both the accuracy of different pitch tracking methods and their optimal parameters may change (see the section on optimization below).

The settings that control `pitchCep` are:

* `cep_threshold`: voicing threshold (defaults to 0.3).
* `cep_smoothing`: the width of smoothing interval (in bins) for finding peaks in the cepstrum. If left NULL, it defaults to 31 for sampling rate 44100 and smaller odd numbers for lower values of sampling rate.
* `cep_zp` (defaults to 0): zero-padding of the spectrum used for cepstral pitch detection (points). Zero-padding may improve the precision of cepstral pitch detection, but it also slows down the algorithm.

```{r fig.show = "hold", fig.height = 5, fig.width = 7}
a = analyze(s, samplingRate = 16000, plot = TRUE, prior_mean = NA,
            pitch_methods = 'cep',
            cep_threshold = .2,
            cep_smoothing = 3,
            nCands = 2)
```
  
#### Spectrum
Frequency domain: ratios of harmonics, BaNa, `pitchSpec`. 
  
All harmonics are multiples of the fundamental frequency. The ratio of two neighboring harmonics is thus predictably related to their rank relative to F0. For example, `(3 * F0) / (2 * F0) = 1.5`, so if we find two harmonics in the spectrum that have a ratio of exactly 1.5, it is likely that these are the first two harmonics, making it possible to calculate F0 (Ba et al., 2012). This is the principle behind the spectral pitch estimate in soundgen, which seems to be particularly useful for noisy, relatively low-pitched sounds.

The settings that control `pitchSpec` are:

* `spec_threshold` (0 to 1, defaults to 0.3): voicing threshold for pitch candidates suggested by the spectral (BaNa) method. The scale is 0 to 1, as usual, but it is the result of a rather arbitrary normalization. The "strength" of spectral pitch candidates is basically calculated as a sigmoid function of the number of harmonic ratios that together converge on the same F0 value. Setting `spec_threshold` too low may produce garbage, while setting it too high makes the spectral method excessively conservative.
* `spec_peak` (0 to 1, defaults to 0.35), `spec_peak_HNRslope` (0 to Inf, defaults to 0.8): when looking for putative harmonics in the spectrum, the threshold for peak detection is calculated as `spec_peak * (1 - HNR * spec_peak_HNRslope)`. For noisy sounds the threshold is high to avoid false sumharmonics, while for tonal sounds it is low to catch weak harmonics. If `HNR` (harmonics-to-noise ratio) is not known, say if we have disabled the autocorrelation pitch tracker or if it returns NA for a frame, then the threshold defaults to simply `spec_peak`. This key parameter strongly affects how many pitch candidates the spectral method suggests.
* `spec_smoothing` (0 to Inf, defaults to 150 Hz): the width of window for detecting peaks in the spectrum, in Hz. You may want to adjust it if you are working with sounds with a specific F0 range, especially if it is unusually high or low compared to human sounds.
* `spec_merge` (0 to Inf semitones, defaults to 1): pitch candidates within `spec_merge` semitones are merged with boosted certainty. Since the idea behind the spectral pitch tracker is that multiple harmonic ratios should converge on the same F0, we have to decide what counts as "the same" F0.
* `spec_singlePeakCert`: (0 to 1, defaults to 0.4) if a`pitchSpec` candidate is calculated based on a single harmonic ratio (as opposed to several ratios converging on the same candidate), its weight (certainty) is taken to be `spec_singlePeakCert`. This mainly has implications for how much we trust spectral vs. other pitch estimates.

```{r fig.show = "hold", fig.height = 5, fig.width = 7}
a = analyze(s, samplingRate = 16000, plot = TRUE, prior_mean = NA,
            pitch_methods = 'spec',
            spec_peak = .6,
            nCands = 3)
```

*TIP As you can guess by now, any pitch tracking method can be tweaked to produce nearly perfect results for any one particular sound (read: to agree with human intuition). The real trick is to find settings that are accurate on average, across a wide range of sounds and recording conditions. The default settings in `analyze` are the result of optimization against manually verified pitch measurements of a corpus of 260 human non-linguistic vocalizations. For other types of sounds, you will need to perform your own manual tweaking and/or formal optimization.*

## Postprocessing of pitch contour
Pitch postprocessing in soundgen includes a whole battery of distinct operations through which the pitch candidates generated by one or more tracking methods are integrated into the final pitch contour. We will look at them one by one, in the order in which they are performed in `analyze`. But first of all, here is how to disable them all:
```{r fig.height = 5, fig.width = 7}
a = analyze(
  s, samplingRate = 16000, plot = TRUE, prior_mean = NA,
  shortest_syl = 0, shortest_pause = 0,  # any length of voiced fragments
  interpol_window = NULL,  # don't interpolate missing F0 values
  pathfinding = 'none',    # don't look for optimal path through candidates
  snake_step = NULL,       # don't run the snake
  smooth_idx = NULL        # don't run median smoothing
)       
```

When the sound is not too tricky and enough pitch candidates are available, as in this example, postprocessing actually makes little difference. In terms of the accuracy of median estimate of F0, you are likely to get a good result even with postprocessing completely disabled. However, if you are interested in the actual intonation contours, postprocessing can help a lot.

### Continuous voiced fragments
It often makes sense to make assumptions about the possible temporal structure of voiced fragments, such as their minimal expected length (`shortest_syl`) and spacing (`shortest_pause`). If these two parameters are positive numbers, the first stage of postprocessing is to divide the sound into continuous voiced fragments that satisfy these assumptions. The default minimal length of a voiced fragment is a single FFT frame. If `shortest_syl` is longer than a single frame, then we need at least two adjacent voiced frames to start a voiced fragment. A single voiced frame surrounded by unvoiced frames then gets discarded (assumed to be unvoiced). If two voiced fragments are separated by less than `shortest_pause`, they are merged. What this means is simply that they are processed as a single syllable by `pathfinder` (see below). No interpolation takes place at this stage.

The next few blocks of postprocessing are performed by an internal function, `soundgen:::pathfinder`. Its input is a matrix of pitch candidates for each frame of a single voiced syllable, usually with multiple candidates per frame. Each candidate is also associated with a different certainty. We want to find a good path through these candidates - that is, a pitch contour that both passes close to the strongest candidates and minimizes pitch jumps, producing a relatively smooth contour. The simplest first approximation is to take a mean of all pitch candidates per frame weighted by their certainty - the "center of gravity" of pitch candidates - and for each frame to select the candidate that lies closest to this center of gravity. This initial guess at a reasonable path may or may not be processed further, depending on the settings described below.

### Interpolation
To make sure we have at least one pitch candidate for every frame in the supposedly continuous voiced fragment, we interpolate to fill in any missing values. The same algorithm also adds new pitch candidates with certainty `interpol_cert` if a frame has no pitch candidates within `interpol_tolerance` of the median of the "center of gravity" estimate over ± `interpol_window` frames. The frequency of new candidates is equal to this median. `interpol_tolerance` defaults to 0.05, which means that new candidates are calculated if there are none within 0.95 to 1.05 times the median over the interpolation window. You can also enable interpolation to fill in unvoiced frames, but without adding new pitch candidates in voiced frames. To do so, set `interpol_tolerance = Inf`.

As an illustration, compare the output of the following two commands:
```{r fig.show = "hold", fig.height = 3, fig.width = 7}
par(mfrow = c(1, 2))
a1 = analyze(s, samplingRate = 16000, plot_spec_pars = NULL, prior_mean = NA,
             pitch_methods = 'cep', cep_threshold = .35, step = 50,
             snake_step = NULL, smooth_idx = 0)  
a2 = analyze(s, samplingRate = 16000, plot_spec_pars = NULL, prior_mean = NA,
             pitch_methods = 'cep', cep_threshold = .35, step = 50,
             snake_step = NULL, smooth_idx = 0,
             interpol_window = NULL)  # disable interpolation
par(mfrow = c(1, 1))
```

*TIP: if you turn off interpolation by setting `interpol_window = NULL`, pathfinder may crash if there are unvoiced gaps in the syllable. In practice, you should either disable interpolation and pathfinding together or set `shortest_pause = 0` to ensure that each continuous voiced fragment, no matter how short, is treated as a separate syllable*

### Pathfinding
The next step after interpolation is pathfinding proper - searching for the optimal path through pitch candidates. If `pathfinding = "none"`, this step is skipped, so we just continue working with the path that lies as close as possible to the (possibly interpolated) center of gravity of pitch candidates. If `pathfinding = "fast"` (the default option), a simple heuristic is employed, in which we walk down the path twice, first left to right and then right to left, trying to minimize the cost measured as a weighted mean of the distance from the center of gravity and the deviation from a smooth contour. The key setting is `cert_weight`, which specifies how much we prioritize the certainty of pitch candidates vs. pitch jumps / the internal tension of the resulting pitch curve. Low `cert_weight` (close to 0): we are mostly concerned with avoiding rapid pitch fluctuations in our contour. High `cert_weight` (close to 1): we mostly pay attention to our certainty in particular pitch candidates.  An example is below. Since this is an illustration of how pathfinding works, all other types of smoothing are disabled, forcing the final pitch contour to pass exactly through existing candidates.

```{r fig.show = "hold", fig.height = 3, fig.width = 7}
par(mfrow = c(1, 2))
a1 = analyze(s, samplingRate = 16000, plot_spec_pars = NULL, prior_mean = NA,
             pitch_methods = 'cep', cep_threshold = .2, nCands = 2,
             snake_step = NULL, smooth_idx = 0, interpol_tolerance = Inf,
             cert_weight = 0)  # minimize pitch jumps
a2 = analyze(s, samplingRate = 16000, plot_spec_pars = NULL, prior_mean = NA,
             pitch_methods = 'cep', cep_threshold = .2, nCands = 2,
             snake_step = NULL, smooth_idx = 0, interpol_tolerance = Inf,
             cert_weight = 1)  # minimize the absolute distance from center of gravity
par(mfrow = c(1, 1))
```

In addition to the default option `pathfinding = 'fast'`, there are two other options. `pathfinding = 'none'` just takes the simplest guess at a reasonable path, namely takes the candidate from each frame that lies closest to the center of gravity for that frame, with no regard for pitch jumps. The final option is `pathfinding = 'slow'`, which calls `stats::optim(method = 'SANN')` to perform pseudo-annealing. This is a more powerful algorithm than the simple heuristic in `pathfinding = 'fast'`, but it is called "slow" for a good reason. If you do have plenty of time, though, it does improve the results, but note that this algorithm is stochastic, so each run may produce different results. Use an additional argument, `control_anneal`, to control the algorithm. See `?stats::optim` for more details. Examples:

```{r fig.show = "hold", fig.height = 3, fig.width = 7}
par(mfrow = c(1, 2))
a1 = analyze(s, samplingRate = 16000, plot_spec_pars = NULL, prior_mean = NA,
             pitch_methods = 'cep', cep_threshold = .2, nCands = 2,
             snake_step = NULL, smooth_idx = 0, interpol_tolerance = Inf,
             pathfinding = 'slow', cert_weight = .25)
a2 = analyze(s, samplingRate = 16000, plot_spec_pars = NULL, prior_mean = NA,
             pitch_methods = 'cep', cep_threshold = .2, nCands = 2,
             snake_step = NULL, smooth_idx = 0, interpol_tolerance = Inf,
             pathfinding = 'none')
par(mfrow = c(1, 1))
```

### Snake
What is here referred to as the "snake" can be seen as an alternative to the pathfinding algorithms above, although both can also be performed sequentially. Whereas pathfinding attempts to find the best path through existing pitch candidates, the snake wiggles the contour under a weighted combination of (a) elastic forces trying to snap the pitch contour to a straight line and (b) the pull of high-certainty pitch candidates. In a sense the snake is thus a combination of interpolation and pathfinding: like interpolation, it can add new values different from existing candidates, and like pathfinding, it balances the certainty in candidates against the smoothness of the resulting contour. 

The only control parameter in the snake module apart from `cert_weight` is `snake_step`, which controls the speed of adaptation (the default is 0.05). The higher it is, the faster the snake "wiggles". This reduces processing time, but the snake risks "overshooting", preventing convergence. If `snake_step` is too low (close to 0), the snake moves too slowly and may fail to reach its optimal configuration. To disable the snake module, set `snake_step = NULL`. You can also produce a separate plot of the snake by setting `snake_plot = TRUE`, as in the example below (again, all other postprocessing is disabled to show what the snake alone will do). The zigzagging line is the initial contour (the path through pitch candidates that lie as close as possible to the center of gravity of each frame), the smooth blue line is the pitch contour after running the snake, and the green traces show the progress of iterative snake adaptation. Note that at `cert_weight = 0.1` the snake is heavily biased towards producing a smooth contour, regardless of its distance from high-certainty pitch candidates.

```{r fig.height = 5, fig.width = 7}
a1 = analyze(s, samplingRate = 16000, plot = FALSE, prior_mean = NA,
             pitch_methods = 'cep', cep_threshold = .2, nCands = 2,
             pathfinding = 'none', smooth_idx = 0, interpol_tolerance = Inf,
             cert_weight = 0.1,  # like pathfinding, the snake is affected by cert_weight
             snake_step = 0.05, snake_plot = TRUE)
```

*TIP Should you use pathfinding, the snake, or both? Pathfinding makes more sense if you want the final contour to pass exactly through existing candidates, say if there are relatively few candidates, most of which are right on target and some completely off. In these conditions the snake will not do much (but not much harm, either). The snake becomes attractive if you have a lot of candidates from different pitch tracking methods, many of which are slightly off and should be averaged. In addition, the more garbage you expect, the more you might want to extrapolate and apply median smoothing*

### Median smoothing
The final postprocessing stage is median smoothing. It is conceptually similar to interpolation, except by now we have only a single F0 value per frame, so we can forget about the multiple candidates and their certainties. It wouldn't make much sense to apply kernel smoothing to this curve: the snake can usually do this in a smarter way, since it does know about the multiple candidates and their certainties. What we want from the smoothing algorithm is to detect and correct only outliers: the values that stick out from the surrounding frames. The parameters that control this module are `smooth_idx` and `smooth_vars`.

If `smooth_idx` is a positive number, contours of the variables in `smooth_vars` are smoothed using a customized version of median smoothing. This modifies only the values that deviate considerably from the moving median and preserves all other values (so this is a bit different from applying a moving median or kernel smoothing). `smooth_idx` controls both the tolerated deviance and the size of the window for calculating a moving median. `smooth_idx = 1` (the default) corresponds to a window of ~100 ms and tolerated deviation of ~4 semitones. 
This smoothing can be applied to any measured value, not only the final pitch contour. The default is `smooth_vars = c('pitch', 'dom')`. To turn off the median smoothing, set `smooth_idx = NULL` or `smooth_vars = NULL`.

```{r fig.show = "hold", fig.height = 3, fig.width = 7}
par(mfrow = c(1, 2))
a1 = analyze(s, samplingRate = 16000, plot_spec_pars = NULL, prior_mean = NA,
             pitch_methods = 'cep', cep_threshold = .2, nCands = 2,
             pathfinding = 'none', snake_step = NULL, interpol_tolerance = Inf,
             smooth_idx = 0)
a2 = analyze(s, samplingRate = 16000, plot_spec_pars = NULL, prior_mean = NA,
             pitch_methods = 'cep', cep_threshold = .2, nCands = 2,
             pathfinding = 'none', snake_step = NULL, interpol_tolerance = Inf,
             smooth_idx = 1)
par(mfrow = c(1, 1))
```

*TIP Pathfinding ("slow", "fast" or "none") is the only postprocessing module that does not deviate from pitch candidates actually returned by pitch tracking algorithms. Interpolation, snake, and median smoothing produce new pitch values per frame, which may be quite different from any actual candidates*

## Customization of pitch plotting
When analyzing a sound, and even when batch-processing an entire folder, it is often helpful to plot both the final pitch contour - perhaps overlaid on a stpectrogram - and individual pitch candidates. You can easily do so from `analyze`, as in all the examples above. The default plotting parameters can also be customized, for example:

```{r fig.height = 5, fig.width = 7}
a = analyze(s, samplingRate = 16000, plot = TRUE, prior_mean = NA,
            plot_spec_pars = list(        # spectrogram: see ?spec
              contrast = .75,
              brightness = -0.5,
              colorTheme = 'seewave',
              ylim = c(0, 4)
              # + other pars passed to seewave::filled.contour.modif2
            ),
            plot_pitch_pars = list(       # final pitch contour (line)
              col = rgb(0, .4, .9, .25),
              lwd = 5,
              lty = 3
              # + other pars passed to base::lines
            ),
            plot_pitchCands_pars = list(  # pitch candidates (points)
              levels = c('autocor', 'cep', 'spec', 'dom'),
              col = c('green', 'violet', 'red', 'orange'),
              pch = c(16, 7, 2, 3),
              cex = 3
            ))
```

You can also suppress plotting any of these three components: the spectrogram, the final pitch contour, or individual pitch candidates. To do so, set the corresponding list of plotting parameters to NULL or NA. In the examples above `plot_spec_pars = NULL` plotted pitch candidates and contour over a blank plot rather than spectrogram. Likewise, we can plot a spectrogram with the final contour only, without individual candidates by setting `plot_pitchCands_par = NULL`.

To save the plot, specify a valid path, for example:
```{r eval = FALSE}
a = analyze(s, samplingRate = 16000, plot = TRUE, savePath = '~/Downloads')
```

This creates a file called 'sound.jpg' 1200 x 800 pixels in size in the indicated folder. For customization, just wrap the call to `analyze` in something like:
```{r eval = FALSE}
jpeg(my.custom.settings.go.here)  # or png(...), or whatever
a = analyze(s, samplingRate = 16000, plot = TRUE)
dev.off()
```

This is simply more efficient than squeezing all these graphical parameters into `analyze`. In practice, the only time you might want to save the output from within `analyze` is when you do batch processing of multiple files with `analyzeFolder` (see below).

## Batch processing with `analyzeFolder`
You may not feel too excited to learn that soundgen contains a wrapper for `analyze` that is meant for analyzing all .wav files in a folder. Indeed, calling `analyze` in a loop will achieve the same result. However, `analyzedFolder` can save you some manual coding, mostly because it can summarize the results. 

`analyze` takes one file at a time and returns a matrix, in which each column corresponds to one acoustic descriptor and each row corresponds to one FFT frame. If you want to preserve all this information for each file in a folder, you can either loop through the files manually or call `analyzeFolder(myfolder, summary = FALSE)`, which returns a list of matrices. In contrast, `analyzeFolder(myfolder, summary = TRUE)` returns a single matrix, in which each acoustic predictor is summarized as the mean, median, and SD of frame-by-frame measurements. Since this is the kind of data you would normally use as input for things like classification of sounds or cluster analysis, this is a convenient shortcut for generating an acoustic dataset for further statistical modeling. In addition, `analyzeFolder` allows you to simultaneously save the plots and prints out estimated time to completion. 

*TIP Processing time varies a lot depending on the exact settings and input, but expect up to a few seconds of machine time per second of audio. The surest way to speed things up is to reduce `step` and to avoid `pathfinding = 'slow'` (other types of postprocessing have very little effect on the speed)*


# Audio segmentation with `segment`

# Self-similarity matrices

# Optimization

```{r}

```

# References
Boersma, 1993
Anikin & Persson, 2017
Ba et al. 2012
