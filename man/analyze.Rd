% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/analyze.R
\name{analyze}
\alias{analyze}
\title{Analyze sound}
\usage{
analyze(x, samplingRate = NULL, silence = 0.04, entropy_threshold = 0.6,
  windowLength = 50, wn = "gaussian", step = 25, zp = 0, zpCep = 2^13,
  pitch_method = c("autocor", "cep", "spec", "dom"), pitch_floor = 75,
  pitch_ceiling = 3500, max_pitch_cands = 4,
  voiced_threshold_autocor = 0.75, voiced_threshold_cep = 0.45,
  voiced_threshold_spec = 0.5, specPitchThreshold_nullNA = 0.5,
  slope_spec = 0.1, width_spec = 150, pitchSpec_only_peak_weight = 0.51,
  prior_mean = HzToSemitones(300), prior_sd = 6, plot_prior = FALSE,
  cutoff_dom = 6000, dom_threshold = 0.1, shortest_syl = 20,
  shortest_pause = 60, interpolWindow = 3, interpolTolerance = 0.3,
  interpolCert = 0.3, postprocess = c("none", "fast", "slow")[2],
  control_anneal = list(maxit = 5000, temp = 1000), certWeight = 0.5,
  snake_step = 0.05, snake_plot = FALSE, smooth_idx = 1,
  smooth_vars = c("pitch", "dom"), plot = TRUE, savePath = NA,
  contrast = 0.2, brightness = 0, ylim = c(0, 5), ...)
}
\arguments{
\item{x}{path to a .wav file or a vector of amplitudes with specified
samplingRate}

\item{samplingRate}{sampling rate of \code{x} (only needed if
\code{x} is a numeric vector, rather than a .wav file)}

\item{silence}{(0 to 1) frames with mean abs amplitude below silence
threshold are not analyzed. NB: this number is dynamically updated: the
actual silence threshold may be higher depending on the quietest frame, but
it will never be lower than this specified number.}

\item{entropy_threshold}{frames with entropy above \code{entropy_threshold}
are not analyzed (assumed to be just noise)}

\item{windowLength}{length of fft window (ms)}

\item{wn}{window type: gaussian, hanning, hamming, bartlett, rectangular, blackman, flattop}

\item{step}{fft step (ms)}

\item{zp}{zero padding (points)}

\item{zpCep}{zero-padding of the spectrum used for cepstral pitch detection
(points). Improves the precision of cepstral pitch detection quite
noticeably.}

\item{pitch_method}{methods of pitch estimation to consider for determining
pitch contour: 'autocor' = autocorrelation (~PRAAT), 'cep' = cepstral,
'spec' = spectral (~BaNa), 'dom' = lowest dominant frequency band}

\item{pitch_floor, pitch_ceiling}{bounds for pitch candidates (Hz)}

\item{max_pitch_cands}{maximum number of pitch candidates to return. NB: only
one dom and one pitchCep is returned, so the remaining candidates come from
the autocorrelation and spectral pitch candidates.}

\item{voiced_threshold_autocor, voiced_threshold_cep, voiced_threshold_spec}{(0
to 1) separate thresholds for detecting pitch candidates with three
different methods: autocorrelation, cepstrum, and BaNa algorithm (see
Details). Note that HNR is still calculated for frames considered to be
unvoiced.}

\item{specPitchThreshold_nullNA, slope_spec}{when looking for putative
harmonics in the spectrum, the threshold for peak detection is calculated as
\code{specPitchThreshold_nullNA * (1 - HNR * slope_spec)}. For noisy sounds the
threshold is high to avoid false sumharmonics, while for tonal sounds it is low
to catch weak harmonics (BaNa - spectral pitch tracking)}

\item{width_spec}{the width of window for detecting peaks in the spectrum
(BaNa - spectral pitch tracking)}

\item{pitchSpec_only_peak_weight}{(0 to 1) if only one pitchSpec candidate is
found, its weight (certainty) is taken to be
\code{pitchSpec_only_peak_weight}. This mainly has implications for how
much we trust the BaNa estimate vs. the autocorrelation estimate of f0.}

\item{prior_mean, prior_sd}{specifies the mean and sd of gamma distribution
describing our prior knowledge about the most likely pitch values for this
file. NB: prior values are specified in semitones above C0, and prior
densities are calculated on the musical scale, not in Hz! Ex.:
\code{prior_mean = HzToSemitones(300), prior_sd = 6} gives a prior with
mean = 300 Hz and SD of 6 semitones (half an octave)}

\item{plot_prior}{if TRUE, produces a separate plot of prior}

\item{cutoff_dom}{do not consider frequencies above cutoff_dom when
calculating the lowest dominant frequency band (recommended if the original
sampling rate varies across different analyzed audio files)}

\item{dom_threshold}{(0 to 1) to find the lowest dominant frequency band, we
do short-term FFT and take the lowest frequency with amplitude at least
dom_threshold}

\item{shortest_syl}{the smallest length of a voiced segment (ms) that
constitutes a syllable (shorter segments will be replaced by NA as if
unvoiced)}

\item{shortest_pause}{the smallest gap between voiced syllables (ms) that
means they shouldn't be merged into one voiced syllable}

\item{interpolWindow, interpolTolerance, interpolCert}{control the behavior of
interpolation algorithm when post-processing pitch candidates. See
\code{\link{pathfinder}} for details.}

\item{postprocess}{method of postprocessing pitch candidates to find the
optimal pitch contour: 'slow' for annealing, 'fast' for a simple heuristic,
'none' for none. See \code{\link{pathfinder}} for details.}

\item{control_anneal}{a list of control parameters for post-processing of
pitch contour with SANN algorithm of \code{\link[stats]{optim}}. This is
only relevant if \code{postprocess} is 'slow'}

\item{certWeight}{(0 to 1) in pitch postprocessing, specifies how much we
prioritize the certainty of pitch candidates vs. pitch jumps / the internal
tension of the resulting pitch curve. High certWeight: we mostly pay
attention to our certainty in particular pitch candidates; low certWeight:
we are more concerned with avoiding rapid pitch fluctuations in our
contour.}

\item{snake_step}{if \code{snake_step} is a positive number, the optimized
path through pitch candidates is further processed to minimize the elastic
force acting on pitch contour. Note that this imposes some smoothing and
thus creates pitch values that were not among candidates. The exact value
of \code{snake_step} controls the speed of snake adaptation.}

\item{snake_plot}{if TRUE, plots the snake (pitch postprocessing)}

\item{smooth_idx, smooth_vars}{if \code{smooth_idx} is a positive number,
contours of the variables in \code{smooth_vars} are smoothed using a
customized version of median smoothing. Modifies only the values that
deviate considerably from the moving median and preserves all other values
(so this is a bit different from applying a moving median or kernel
smoothing). \code{smooth_idx} controls both the tolerated deviance and the
size of the window for calculating a moving median. \code{smooth_idx} of 1
corresponds to a window of ~100 ms and tolerated deviation of ~4 semitones.}

\item{plot}{if TRUE, produces a spectrogram with pitch contour overlaid}

\item{savePath}{if a valid path is specified, the plot is saved in this folder (defaults to NA)}

\item{contrast}{spectrum is exponentiated by contrast (-inf to +inf,
recommended -1 to +1). Contrast >0 increases sharpness, <0 decreases
harpness}

\item{brightness}{how much to "lighten" the image (>0 = lighter, <0 = darker)}

\item{ylim}{frequency range to plot, kHz (defaults to 0 to Nyquist frequency)}

\item{...}{other graphical parameters passed to \code{\link{spec}}}
}
\value{
Returns a dataframe with one row per FFT frame and one column per acoustic variable.
  The best guess at the pitch contour considering all available information
  is stored in the variable called "pitch". In addition, the output contains
  pitch estimates based on three separate algorithms: autocorrelation
  (pitchAutocor), cepstrum (pitchCep), and BaNa (pitchSpec).
}
\description{
Acoustic analysis of a single sound file.
}
\examples{
sound1 = generateBout(sylDur_mean = 900, pitchAnchors = list(
  time = c(0, .3, .8, 1), value = c(300, 900, 400, 2300)),
  breathingAnchors = list(time = c(0, 900), value = c(-40, 00)),
  temperature = 0)
playme(sound1, 16000)
a1 = analyze(sound1, samplingRate = 16000, plot = TRUE)
# or, to improve the quality of post-processing:
a1 = analyze(sound1, samplingRate = 16000, plot = TRUE, postprocess = 'slow')
median(a1$pitch, na.rm = TRUE)  # 625 Hz

# the same pitch contour, but harder to analyze b/c of subharmonics and jitter
sound2 = generateBout(sylDur_mean = 900, pitchAnchors = list(
  time = c(0, .3, .8, 1), value = c(300, 900, 400, 2300)),
  breathingAnchors = list(time = c(0, 900), value = c(-40, 20)),
  sidebands_width = 200, jitterDep = 0.5, noiseAmount = 100, temperature = 0)
playme(sound2, 16000)
a2 = analyze(sound2, samplingRate = 16000, plot = TRUE, postprocess = 'slow')
# many pitch candidates are off, but the overall contour and estimate of
# median pitch are pretty similar:
median(a2$pitch, na.rm = TRUE)  # 595 Hz
median(a2$HNR, na.rm = TRUE)  # HNR of 4 dB
}
