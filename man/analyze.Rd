% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/analyze.R
\name{analyze}
\alias{analyze}
\title{Analyze sound}
\usage{
analyze(x, samplingRate = NULL, silence = 0.04, entropy_threshold = 0.6,
  windowLength = 50, wn = "gaussian", step = 25, zp = 0, zpCep = 2^13,
  pitch_methods = c("autocor", "spec", "dom"), min_voiced_cands = "autom",
  pitch_floor = 75, pitch_ceiling = 3500, nCands = 1,
  dom_threshold = 0.1, dom_smoothing_width = NULL,
  voiced_threshold_autocor = 0.7, autocor_smoothing_width = NULL,
  voiced_threshold_cep = 0.45, voiced_threshold_spec = 0.3,
  specPitchThreshold_nullNA = 0.35, pitchSpec_only_peak_weight = 0.4,
  slope_spec = 0.8, width_spec = 150, merge_semitones = 1,
  prior_mean = HzToSemitones(300), prior_sd = 6, plot_prior = FALSE,
  cutoff_freq = 6000, shortest_syl = 20, shortest_pause = 60,
  interpolWindow = 3, interpolTolerance = 0.3, interpolCert = 0.3,
  postprocess = c("none", "fast", "slow")[2], control_anneal = list(maxit =
  5000, temp = 1000), certWeight = 0.5, snake_step = 0.05,
  snake_plot = FALSE, smooth_idx = 1, smooth_vars = c("pitch", "dom"),
  plot = TRUE, savePath = NA, plot_spec_pars = list(contrast = 0.2,
  brightness = 0, ylim = c(0, 5)), plot_pitch_pars = list(col = rgb(0, 0, 1,
  0.75), lwd = 3), plot_pitchCands_pars = list(levels = c("autocor", "spec",
  "dom", "cep"), col = c("green", "red", "orange", "violet"), pch = c(16, 2, 3,
  7), cex = 2))
}
\arguments{
\item{x}{path to a .wav file or a vector of amplitudes with specified
samplingRate}

\item{samplingRate}{sampling rate of \code{x} (only needed if
\code{x} is a numeric vector, rather than a .wav file)}

\item{silence}{(0 to 1) frames with mean abs amplitude below silence
threshold are not analyzed. NB: this number is dynamically updated: the
actual silence threshold may be higher depending on the quietest frame, but
it will never be lower than this specified number.}

\item{entropy_threshold}{frames with entropy above \code{entropy_threshold}
are not analyzed (assumed to be just noise)}

\item{windowLength}{length of fft window, ms}

\item{wn}{window type: gaussian, hanning, hamming, bartlett, rectangular,
blackman, flattop}

\item{step}{fft step, ms}

\item{zp}{zero padding, points}

\item{zpCep}{zero-padding of the spectrum used for cepstral pitch detection
(points). Improves the precision of cepstral pitch detection quite
noticeably.}

\item{pitch_methods}{methods of pitch estimation to consider for determining
pitch contour: 'autocor' = autocorrelation (~PRAAT), 'cep' = cepstral,
'spec' = spectral (~BaNa), 'dom' = lowest dominant frequency band}

\item{min_voiced_cands}{minimum number of pitch candidates that have to be
defined to consider a frame voiced (defaults to 2 if \code{dom} is among
the candidates and 1 otherwise)}

\item{pitch_floor, pitch_ceiling}{bounds for pitch candidates (Hz)}

\item{nCands}{maximum number of pitch candidates to use per method (dom and
cepstrum always use only one candidate each).}

\item{dom_threshold}{(0 to 1) to find the lowest dominant frequency band, we
do short-term FFT and take the lowest frequency with amplitude at least
dom_threshold}

\item{dom_smoothing_width}{the width of smoothing interval (Hz) for finding
the lowest spectral peak (lowest dominant frequency band). If \code{NULL},
defaults to ~220 Hz}

\item{voiced_threshold_autocor, voiced_threshold_cep, voiced_threshold_spec}{(0
to 1) separate thresholds for detecting pitch candidates with three
different methods: autocorrelation, cepstrum, and BaNa algorithm (see
Details). Note that HNR is still calculated for frames considered to be
unvoiced.}

\item{autocor_smoothing_width}{the width of smoothing interval (points) for
finding peaks in the autocorrelation function. Defaults to 7 for sampling
rate 44100 and smaller odd numbers for lower values of sampling rate}

\item{specPitchThreshold_nullNA, slope_spec}{when looking for putative
harmonics in the spectrum, the threshold for peak detection is calculated as
\code{specPitchThreshold_nullNA * (1 - HNR * slope_spec)}. For noisy sounds the
threshold is high to avoid false sumharmonics, while for tonal sounds it is low
to catch weak harmonics (BaNa - spectral pitch tracking)}

\item{pitchSpec_only_peak_weight}{(0 to 1) if only one pitchSpec candidate is
found, its weight (certainty) is taken to be
\code{pitchSpec_only_peak_weight}. This mainly has implications for how
much we trust the BaNa estimate vs. the autocorrelation estimate of f0.}

\item{width_spec}{the width of window for detecting peaks in the spectrum
(BaNa - spectral pitch tracking)}

\item{merge_semitones}{pitch candidates within \code{merge_semitones} are
merged with boosted certainty (BaNa - spectral pitch tracking)}

\item{prior_mean, prior_sd}{specifies the mean and sd of gamma distribution
describing our prior knowledge about the most likely pitch values for this
file. NB: prior values are specified in semitones above C0, and prior
densities are calculated on the musical scale, not in Hz! Ex.:
\code{prior_mean = HzToSemitones(300), prior_sd = 6} gives a prior with
mean = 300 Hz and SD of 6 semitones (half an octave)}

\item{plot_prior}{if TRUE, produces a separate plot of the prior}

\item{cutoff_freq}{repeat the calculation of spectral descriptives after
discarding all info above \code{cutoff_freq} (Hz). Recommended if the
original sampling rate varies across different analyzed audio files}

\item{shortest_syl}{the smallest length of a voiced segment (ms) that
constitutes a syllable (shorter segments will be replaced by NA as if
unvoiced)}

\item{shortest_pause}{the smallest gap between voiced syllables (ms) that
means they shouldn't be merged into one voiced syllable}

\item{interpolWindow, interpolTolerance, interpolCert}{control the behavior of
interpolation algorithm when post-processing pitch candidates. See
\code{\link{pathfinder}} for details.}

\item{postprocess}{method of postprocessing pitch candidates to find the
optimal pitch contour: 'slow' for annealing, 'fast' for a simple heuristic,
'none' for none. See \code{\link{pathfinder}} for details.}

\item{control_anneal}{a list of control parameters for post-processing of
pitch contour with SANN algorithm of \code{\link[stats]{optim}}. This is
only relevant if \code{postprocess} is 'slow'}

\item{certWeight}{(0 to 1) in pitch postprocessing, specifies how much we
prioritize the certainty of pitch candidates vs. pitch jumps / the internal
tension of the resulting pitch curve. High certWeight: we mostly pay
attention to our certainty in particular pitch candidates; low certWeight:
we are more concerned with avoiding rapid pitch fluctuations in our
contour.}

\item{snake_step}{if \code{snake_step} is a positive number, the optimized
path through pitch candidates is further processed to minimize the elastic
force acting on pitch contour. Note that this imposes some smoothing and
thus creates pitch values that were not among candidates. The exact value
of \code{snake_step} controls the speed of snake adaptation.}

\item{snake_plot}{if TRUE, plots the snake (pitch postprocessing)}

\item{smooth_idx, smooth_vars}{if \code{smooth_idx} is a positive number,
contours of the variables in \code{smooth_vars} are smoothed using a
customized version of median smoothing. Modifies only the values that
deviate considerably from the moving median and preserves all other values
(so this is a bit different from applying a moving median or kernel
smoothing). \code{smooth_idx} controls both the tolerated deviance and the
size of the window for calculating a moving median. \code{smooth_idx} of 1
corresponds to a window of ~100 ms and tolerated deviation of ~4 semitones.}

\item{plot}{if TRUE, produces a spectrogram with pitch contour overlaid}

\item{savePath}{if a valid path is specified, the plot is saved in this
folder (defaults to NA)}

\item{plot_spec_pars}{a list of graphical parameters passed on to
\code{\link{spec}}. Set to \code{NULL} or \code{NA} to suppress plotting
the spectrogram}

\item{plot_pitch_pars}{a list of graphical parameters for displaying the
final pitch contour. Set to \code{NULL} or \code{NA} to suppress}

\item{plot_pitchCands_pars}{a list of graphical parameters for displaying
individual pitch candidates. Set to \code{NULL} or \code{NA} to suppress}
}
\value{
Returns a dataframe with one row per FFT frame and one column per
  acoustic variable. The best guess at the pitch contour considering all
  available information is stored in the variable called "pitch". In
  addition, the output contains pitch estimates based on three separate
  algorithms: autocorrelation (pitchAutocor), cepstrum (pitchCep), and BaNa
  (pitchSpec).
}
\description{
Acoustic analysis of a single sound file: pitch tracking and basic spectral
characteristics. The default values of arguments are optimized for human
non-linguistic vocalizations. See the vignette for details.
}
\examples{
sound1 = soundgen(sylDur_mean = 900, pitchAnchors = list(
  time = c(0, .3, .8, 1), value = c(300, 900, 400, 2300)),
  breathingAnchors = list(time = c(0, 900), value = c(-40, 00)),
  temperature = 0)
playme(sound1, 16000)
a1 = analyze(sound1, samplingRate = 16000, plot = TRUE)
# or, to improve the quality of post-processing:
a1 = analyze(sound1, samplingRate = 16000, plot = TRUE, postprocess = 'slow')
median(a1$pitch, na.rm = TRUE)  # 614 Hz
# (can vary, since postprocessing is stochastic)
# compare to the true value:
median(getSmoothContour(anchors = list(time = c(0, .3, .8, 1),
  value = c(300, 900, 400, 2300)), len = 1000))  # 611 Hz

# the same pitch contour, but harder to analyze b/c of subharmonics and jitter
sound2 = soundgen(sylDur_mean = 900, pitchAnchors = list(
  time = c(0, .3, .8, 1), value = c(300, 900, 400, 2300)),
  breathingAnchors = list(time = c(0, 900), value = c(-40, 20)),
  sidebands_width = 200, jitterDep = 0.5, noiseAmount = 100, temperature = 0)
playme(sound2, 16000)
a2 = analyze(sound2, samplingRate = 16000, plot = TRUE, postprocess = 'slow')
# many pitch candidates are off, but the overall contour and estimate of
# median pitch are pretty similar:
median(a2$pitch, na.rm = TRUE)  # 622 Hz (can vary, since post-processing is stochastic)
median(a2$HNR, na.rm = TRUE)  # HNR of 3-4 dB

# Fancy plotting options:
a = analyze(sound2, samplingRate = 16000, plot = TRUE,
  plot_spec_pars = list(xlab = 'Time, ms', colorTheme = 'seewave', contrast = .8),
  plot_pitchCands_pars = list(cex = 3, col = c('gray70', 'yellow', 'purple', 'maroon')),
  plot_pitch_pars = list(col = 'black', lty = 3, lwd = 3))

# Plot pitch candidates w/o a spectrogram
a = analyze(sound2, samplingRate = 16000, plot = TRUE, plot_spec_pars = NA)
}
