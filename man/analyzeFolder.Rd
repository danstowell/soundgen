% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/analyze.R
\name{analyzeFolder}
\alias{analyzeFolder}
\title{Analyze sound}
\usage{
analyzeFolder(myfolder, samplingRate = NULL, silence = 0.04,
  windowLength = 50, wn = "gaussian", step = 25, zp = 0,
  cutoff_freq = 6000, pitch_methods = c("autocor", "spec", "dom"),
  entropy_threshold = 0.6, pitch_floor = 75, pitch_ceiling = 3500,
  prior_mean = HzToSemitones(300), prior_sd = 6, prior_plot = FALSE,
  nCands = 1, min_voiced_cands = "autom", dom_threshold = 0.1,
  dom_smoothing = 220, autocor_threshold = 0.7, autocor_smoothing = NULL,
  cep_threshold = 0.45, cep_smoothing = NULL, cep_zp = 2^13,
  spec_threshold = 0.3, spec_peak = 0.35, spec_singlePeakCert = 0.4,
  spec_peak_HNRslope = 0.8, spec_smoothing = 150, spec_merge = 1,
  shortest_syl = 20, shortest_pause = 60, interpol_window = 3,
  interpol_tolerance = 0.3, interpol_cert = 0.3, pathfinding = c("none",
  "fast", "slow")[2], control_anneal = list(maxit = 5000, temp = 1000),
  cert_weight = 0.5, snake_step = 0.05, snake_plot = FALSE,
  smooth_idx = 1, smooth_vars = c("pitch", "dom"), plot = TRUE,
  savePath = NA, plot_spec_pars = list(contrast = 0.2, brightness = 0, ylim
  = c(0, 5)), plot_pitch_pars = list(col = rgb(0, 0, 1, 0.75), lwd = 3),
  plot_pitchCands_pars = list(levels = c("autocor", "cep", "spec", "dom"), col
  = c("green", "violet", "red", "orange"), pch = c(16, 7, 2, 3), cex = 2),
  summary = TRUE, verbose = TRUE)
}
\arguments{
\item{myfolder}{full path to target folder}

\item{samplingRate}{sampling rate of \code{x} (only needed if
\code{x} is a numeric vector, rather than a .wav file)}

\item{silence}{(0 to 1) frames with mean abs amplitude below silence
threshold are not analyzed at all. NB: this number is dynamically updated:
the actual silence threshold may be higher depending on the quietest frame,
but it will never be lower than this specified number.}

\item{windowLength}{length of fft window, ms}

\item{wn}{window type: gaussian, hanning, hamming, bartlett, rectangular,
blackman, flattop}

\item{step}{fft step, ms}

\item{zp}{zero padding, points}

\item{cutoff_freq}{repeat the calculation of spectral descriptives after
discarding all info above \code{cutoff_freq} (Hz). Recommended if the
original sampling rate varies across different analyzed audio files}

\item{pitch_methods}{methods of pitch estimation to consider for determining
pitch contour: 'autocor' = autocorrelation (~PRAAT), 'cep' = cepstral,
'spec' = spectral (~BaNa), 'dom' = lowest dominant frequency band}

\item{entropy_threshold}{pitch tracking is not applied to frames with entropy
above \code{entropy_threshold} (assumed to be just noise), but other
spectral descriptives are still calculated}

\item{pitch_floor}{absolute bounds for pitch candidates (Hz)}

\item{pitch_ceiling}{absolute bounds for pitch candidates (Hz)}

\item{prior_mean}{specifies the mean and sd of gamma distribution
describing our prior knowledge about the most likely pitch values for this
file. NB: prior values are specified in semitones above C0, and prior
densities are calculated on the musical scale, not in Hz! Ex.:
\code{prior_mean = HzToSemitones(300), prior_sd = 6} gives a prior with
mean = 300 Hz and SD of 6 semitones (half an octave)}

\item{prior_sd}{specifies the mean and sd of gamma distribution
describing our prior knowledge about the most likely pitch values for this
file. NB: prior values are specified in semitones above C0, and prior
densities are calculated on the musical scale, not in Hz! Ex.:
\code{prior_mean = HzToSemitones(300), prior_sd = 6} gives a prior with
mean = 300 Hz and SD of 6 semitones (half an octave)}

\item{prior_plot}{if TRUE, produces a separate plot of the prior}

\item{nCands}{maximum number of pitch candidates to use per method (except
for \code{dom}, which returns at most one candidate per frame)}

\item{min_voiced_cands}{minimum number of pitch candidates that have to be
defined to consider a frame voiced (defaults to 2 if \code{dom} is among
the candidates and 1 otherwise)}

\item{dom_threshold}{(0 to 1) to find the lowest dominant frequency band, we
do short-term FFT and take the lowest frequency with amplitude at least
dom_threshold}

\item{dom_smoothing}{the width of smoothing interval (Hz) for finding
the lowest spectral peak (lowest dominant frequency band)}

\item{autocor_threshold}{(0 to 1) separate
voicing thresholds for detecting pitch candidates with three different
methods: autocorrelation, cepstrum, and BaNa algorithm (see Details). Note
that HNR is still calculated for frames considered to be unvoiced.}

\item{autocor_smoothing}{the width of smoothing interval (in bins) for
finding peaks in the autocorrelation function. Defaults to 7 for sampling
rate 44100 and smaller odd numbers for lower values of sampling rate}

\item{cep_threshold}{(0 to 1) separate
voicing thresholds for detecting pitch candidates with three different
methods: autocorrelation, cepstrum, and BaNa algorithm (see Details). Note
that HNR is still calculated for frames considered to be unvoiced.}

\item{cep_smoothing}{the width of smoothing interval (in bins) for finding
peaks in the cepstrum. Defaults to 7 for sampling rate 44100 and smaller
odd numbers for lower values of sampling rate}

\item{cep_zp}{zero-padding of the spectrum used for cepstral pitch detection
(points). Improves the precision of cepstral pitch detection quite
noticeably.}

\item{spec_threshold}{(0 to 1) separate
voicing thresholds for detecting pitch candidates with three different
methods: autocorrelation, cepstrum, and BaNa algorithm (see Details). Note
that HNR is still calculated for frames considered to be unvoiced.}

\item{spec_peak}{when looking for putative
harmonics in the spectrum, the threshold for peak detection is calculated as
\code{spec_peak * (1 - HNR * spec_peak_HNRslope)}. For noisy sounds the
threshold is high to avoid false sumharmonics, while for tonal sounds it is low
to catch weak harmonics}

\item{spec_singlePeakCert}{(0 to 1) if only one pitchSpec candidate is
found, its weight (certainty) is taken to be
\code{spec_singlePeakCert}}

\item{spec_peak_HNRslope}{when looking for putative
harmonics in the spectrum, the threshold for peak detection is calculated as
\code{spec_peak * (1 - HNR * spec_peak_HNRslope)}. For noisy sounds the
threshold is high to avoid false sumharmonics, while for tonal sounds it is low
to catch weak harmonics}

\item{spec_smoothing}{the width of window for detecting peaks in the spectrum, Hz}

\item{spec_merge}{pitch candidates within \code{spec_merge} are
merged with boosted certainty}

\item{shortest_syl}{the smallest length of a voiced segment (ms) that
constitutes a syllable (shorter segments will be replaced by NA as if
unvoiced)}

\item{shortest_pause}{the smallest gap between voiced syllables (ms) that
means they shouldn't be merged into one voiced syllable}

\item{interpol_window}{control the behavior of
interpolation algorithm when postprocessing pitch candidates. To turn off
interpolation, set \code{interpol_window} to NULL. See
\code{\link{pathfinder}} for details.}

\item{interpol_tolerance}{control the behavior of
interpolation algorithm when postprocessing pitch candidates. To turn off
interpolation, set \code{interpol_window} to NULL. See
\code{\link{pathfinder}} for details.}

\item{interpol_cert}{control the behavior of
interpolation algorithm when postprocessing pitch candidates. To turn off
interpolation, set \code{interpol_window} to NULL. See
\code{\link{pathfinder}} for details.}

\item{pathfinding}{method of finding the optimal path through pitch
candidates: 'slow' for annealing, 'fast' for a simple heuristic, 'none' for
none. See \code{\link{pathfinder}} for details.}

\item{control_anneal}{a list of control parameters for postprocessing of
pitch contour with SANN algorithm of \code{\link[stats]{optim}}. This is
only relevant if \code{pathfinding} is 'slow'}

\item{cert_weight}{(0 to 1) in pitch postprocessing, specifies how much we
prioritize the certainty of pitch candidates vs. pitch jumps / the internal
tension of the resulting pitch curve. High cert_weight: we mostly pay
attention to our certainty in particular pitch candidates; low cert_weight:
we are more concerned with avoiding rapid pitch fluctuations in our
contour.}

\item{snake_step}{if \code{snake_step} is a positive number, the optimized
path through pitch candidates is further processed to minimize the elastic
force acting on pitch contour. Note that this imposes some smoothing and
thus creates pitch values that were not among candidates. The exact value
of \code{snake_step} controls the speed of snake adaptation. To turn off
the snake module, set \code{snake_step} to NULL}

\item{snake_plot}{if TRUE, plots the snake (pitch postprocessing)}

\item{smooth_idx}{if \code{smooth_idx} is a positive number,
contours of the variables in \code{smooth_vars} are smoothed using a
customized version of median smoothing. Modifies only the values that
deviate considerably from the moving median and preserves all other values
(so this is a bit different from applying a moving median or kernel
smoothing). \code{smooth_idx} controls both the tolerated deviance and the
size of the window for calculating a moving median. \code{smooth_idx} of 1
corresponds to a window of ~100 ms and tolerated deviation of ~4 semitones.
To turn off the median smoothing, set \code{smooth_idx} or
\code{smooth_vars} to NULL.}

\item{smooth_vars}{if \code{smooth_idx} is a positive number,
contours of the variables in \code{smooth_vars} are smoothed using a
customized version of median smoothing. Modifies only the values that
deviate considerably from the moving median and preserves all other values
(so this is a bit different from applying a moving median or kernel
smoothing). \code{smooth_idx} controls both the tolerated deviance and the
size of the window for calculating a moving median. \code{smooth_idx} of 1
corresponds to a window of ~100 ms and tolerated deviation of ~4 semitones.
To turn off the median smoothing, set \code{smooth_idx} or
\code{smooth_vars} to NULL.}

\item{plot}{if TRUE, produces a spectrogram with pitch contour overlaid}

\item{savePath}{if a valid path is specified, the plot is saved in this
folder (defaults to NA)}

\item{plot_spec_pars}{a list of graphical parameters passed on to
\code{\link{spec}}. Set to \code{NULL} or \code{NA} to suppress plotting
the spectrogram}

\item{plot_pitch_pars}{a list of graphical parameters for displaying the
final pitch contour. Set to \code{NULL} or \code{NA} to suppress}

\item{plot_pitchCands_pars}{a list of graphical parameters for displaying
individual pitch candidates. Set to \code{NULL} or \code{NA} to suppress}

\item{summary}{if TRUE, summarizes acoustics per file}

\item{verbose}{if TRUE, reports progress and estimated time left}
}
\value{
If \code{summary} is TRUE, returns a dataframe with one row per audio
  file. If \code{summary} is FALSE, returns a list of detailed descriptives.
}
\description{
Acoustic analysis of all .wav files in a folder.
}
\examples{
\dontrun{
# download 260 sounds from Anikin & Persson (2017)
# http://cogsci.se/personal/results/
# 01_anikin-persson_2016_naturalistics-non-linguistic-vocalizations/260sounds_wav.zip
# unzip them into a folder, say '~/Downloads/temp'
myfolder = '~/Downloads/temp'  # 260 .wav files live here
s = analyzeFolder(myfolder, pathfinding = 'slow', verbose = TRUE)

# Check accuracy: import manually verified pitch values (our "key")
key = pitch_manual  # a vector of 260 floats
trial = s$pitch_median
cor(key, trial, use = 'pairwise.complete.obs')
plot(log(key), log(trial))
abline(a=0, b=1, col='red')
}
}
