% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/analyze.R
\name{analyzeFolder}
\alias{analyzeFolder}
\title{Analyze sound}
\usage{
analyzeFolder(myfolder, samplingRate = NULL, silence = 0.04,
  entropy_threshold = 0.6, windowLength = 50, wn = "gaussian",
  step = 25, zp = 0, zpCep = 2^13, pitch_methods = c("autocor", "cep",
  "spec", "dom"), min_voiced_cands = "autom", pitch_floor = 75,
  pitch_ceiling = 3500, nCands = 1, dom_threshold = 0.1,
  dom_smoothing_width = NULL, voiced_threshold_autocor = 0.7,
  autocor_smoothing_width = NULL, voiced_threshold_cep = 0.45,
  voiced_threshold_spec = 0.3, specPitchThreshold_nullNA = 0.35,
  pitchSpec_only_peak_weight = 0.4, slope_spec = 0.8, width_spec = 150,
  merge_semitones = 1, prior_mean = HzToSemitones(300), prior_sd = 6,
  plot_prior = FALSE, cutoff_freq = 6000, shortest_syl = 20,
  shortest_pause = 60, interpolWindow = 3, interpolTolerance = 0.3,
  interpolCert = 0.3, postprocess = c("none", "fast", "slow")[2],
  control_anneal = list(maxit = 5000, temp = 1000), certWeight = 0.5,
  snake_step = 0.05, snake_plot = FALSE, smooth_idx = 1,
  smooth_vars = c("pitch", "dom"), plot = TRUE, savePath = NA,
  plot_spec_pars = list(contrast = 0.2, brightness = 0, ylim = c(0, 5)),
  plot_pitch_pars = list(col = rgb(0, 0, 1, 0.75), lwd = 3),
  plot_pitchCands_pars = list(levels = c("autocor", "cep", "spec", "dom"), col
  = c("green", "violet", "red", "orange"), pch = c(16, 7, 2, 3), cex = 2),
  summary = TRUE, verbose = TRUE)
}
\arguments{
\item{myfolder}{full path to target folder}

\item{samplingRate}{sampling rate of \code{x} (only needed if
\code{x} is a numeric vector, rather than a .wav file)}

\item{silence}{(0 to 1) frames with mean abs amplitude below silence
threshold are not analyzed. NB: this number is dynamically updated: the
actual silence threshold may be higher depending on the quietest frame, but
it will never be lower than this specified number.}

\item{entropy_threshold}{frames with entropy above \code{entropy_threshold}
are not analyzed (assumed to be just noise)}

\item{windowLength}{length of fft window (ms)}

\item{wn}{window type: gaussian, hanning, hamming, bartlett, rectangular, blackman, flattop}

\item{step}{fft step (ms)}

\item{zp}{zero padding (points)}

\item{zpCep}{zero-padding of the spectrum used for cepstral pitch detection
(points). Improves the precision of cepstral pitch detection quite
noticeably.}

\item{pitch_methods}{methods of pitch estimation to consider for determining
pitch contour: 'autocor' = autocorrelation (~PRAAT), 'cep' = cepstral,
'spec' = spectral (~BaNa), 'dom' = lowest dominant frequency band}

\item{min_voiced_cands}{minimum number of pitch candidates that have to be
defined to consider a frame voiced (defaults to 2 if \code{dom} is among
the candidates and 1 otherwise)}

\item{pitch_floor}{bounds for pitch candidates (Hz)}

\item{pitch_ceiling}{bounds for pitch candidates (Hz)}

\item{nCands}{maximum number of pitch candidates to use per method (dom and
cepstrum always use only one candidate each).}

\item{dom_threshold}{(0 to 1) to find the lowest dominant frequency band, we
do short-term FFT and take the lowest frequency with amplitude at least
dom_threshold}

\item{dom_smoothing_width}{the width of smoothing interval (Hz) for finding
the lowest spectral peak (lowest dominant frequency band). If \code{NULL},
defaults to ~220 Hz}

\item{voiced_threshold_autocor}{(0
to 1) separate thresholds for detecting pitch candidates with three
different methods: autocorrelation, cepstrum, and BaNa algorithm (see
Details). Note that HNR is still calculated for frames considered to be
unvoiced.}

\item{autocor_smoothing_width}{the width of smoothing interval (points) for
finding peaks in the autocorrelation function. Defaults to 7 for sampling
rate 44100 and smaller odd numbers for lower values of sampling rate}

\item{voiced_threshold_cep}{(0
to 1) separate thresholds for detecting pitch candidates with three
different methods: autocorrelation, cepstrum, and BaNa algorithm (see
Details). Note that HNR is still calculated for frames considered to be
unvoiced.}

\item{voiced_threshold_spec}{(0
to 1) separate thresholds for detecting pitch candidates with three
different methods: autocorrelation, cepstrum, and BaNa algorithm (see
Details). Note that HNR is still calculated for frames considered to be
unvoiced.}

\item{specPitchThreshold_nullNA}{when looking for putative
harmonics in the spectrum, the threshold for peak detection is calculated as
\code{specPitchThreshold_nullNA * (1 - HNR * slope_spec)}. For noisy sounds the
threshold is high to avoid false sumharmonics, while for tonal sounds it is low
to catch weak harmonics (BaNa - spectral pitch tracking)}

\item{pitchSpec_only_peak_weight}{(0 to 1) if only one pitchSpec candidate is
found, its weight (certainty) is taken to be
\code{pitchSpec_only_peak_weight}. This mainly has implications for how
much we trust the BaNa estimate vs. the autocorrelation estimate of f0.}

\item{slope_spec}{when looking for putative
harmonics in the spectrum, the threshold for peak detection is calculated as
\code{specPitchThreshold_nullNA * (1 - HNR * slope_spec)}. For noisy sounds the
threshold is high to avoid false sumharmonics, while for tonal sounds it is low
to catch weak harmonics (BaNa - spectral pitch tracking)}

\item{width_spec}{the width of window for detecting peaks in the spectrum
(BaNa - spectral pitch tracking)}

\item{merge_semitones}{pitch candidates within \code{merge_semitones} are
merged with boosted certainty (BaNa - spectral pitch tracking)}

\item{prior_mean}{specifies the mean and sd of gamma distribution
describing our prior knowledge about the most likely pitch values for this
file. NB: prior values are specified in semitones above C0, and prior
densities are calculated on the musical scale, not in Hz! Ex.:
\code{prior_mean = HzToSemitones(300), prior_sd = 6} gives a prior with
mean = 300 Hz and SD of 6 semitones (half an octave)}

\item{prior_sd}{specifies the mean and sd of gamma distribution
describing our prior knowledge about the most likely pitch values for this
file. NB: prior values are specified in semitones above C0, and prior
densities are calculated on the musical scale, not in Hz! Ex.:
\code{prior_mean = HzToSemitones(300), prior_sd = 6} gives a prior with
mean = 300 Hz and SD of 6 semitones (half an octave)}

\item{plot_prior}{if TRUE, produces a separate plot of the prior}

\item{cutoff_freq}{repeat the calculation of spectral descriptives after
discarding all info above \code{cutoff_freq} (Hz). Recommended if the
original sampling rate varies across different analyzed audio files}

\item{shortest_syl}{the smallest length of a voiced segment (ms) that
constitutes a syllable (shorter segments will be replaced by NA as if
unvoiced)}

\item{shortest_pause}{the smallest gap between voiced syllables (ms) that
means they shouldn't be merged into one voiced syllable}

\item{interpolWindow}{control the behavior of
interpolation algorithm when post-processing pitch candidates. See
\code{\link{pathfinder}} for details.}

\item{interpolTolerance}{control the behavior of
interpolation algorithm when post-processing pitch candidates. See
\code{\link{pathfinder}} for details.}

\item{interpolCert}{control the behavior of
interpolation algorithm when post-processing pitch candidates. See
\code{\link{pathfinder}} for details.}

\item{postprocess}{method of postprocessing pitch candidates to find the
optimal pitch contour: 'slow' for annealing, 'fast' for a simple heuristic,
'none' for none. See \code{\link{pathfinder}} for details.}

\item{control_anneal}{a list of control parameters for post-processing of
pitch contour with SANN algorithm of \code{\link[stats]{optim}}. This is
only relevant if \code{postprocess} is 'slow'}

\item{certWeight}{(0 to 1) in pitch postprocessing, specifies how much we
prioritize the certainty of pitch candidates vs. pitch jumps / the internal
tension of the resulting pitch curve. High certWeight: we mostly pay
attention to our certainty in particular pitch candidates; low certWeight:
we are more concerned with avoiding rapid pitch fluctuations in our
contour.}

\item{snake_step}{if \code{snake_step} is a positive number, the optimized
path through pitch candidates is further processed to minimize the elastic
force acting on pitch contour. Note that this imposes some smoothing and
thus creates pitch values that were not among candidates. The exact value
of \code{snake_step} controls the speed of snake adaptation.}

\item{snake_plot}{if TRUE, plots the snake (pitch postprocessing)}

\item{smooth_idx}{if \code{smooth_idx} is a positive number,
contours of the variables in \code{smooth_vars} are smoothed using a
customized version of median smoothing. Modifies only the values that
deviate considerably from the moving median and preserves all other values
(so this is a bit different from applying a moving median or kernel
smoothing). \code{smooth_idx} controls both the tolerated deviance and the
size of the window for calculating a moving median. \code{smooth_idx} of 1
corresponds to a window of ~100 ms and tolerated deviation of ~4 semitones.}

\item{smooth_vars}{if \code{smooth_idx} is a positive number,
contours of the variables in \code{smooth_vars} are smoothed using a
customized version of median smoothing. Modifies only the values that
deviate considerably from the moving median and preserves all other values
(so this is a bit different from applying a moving median or kernel
smoothing). \code{smooth_idx} controls both the tolerated deviance and the
size of the window for calculating a moving median. \code{smooth_idx} of 1
corresponds to a window of ~100 ms and tolerated deviation of ~4 semitones.}

\item{plot}{if TRUE, produces a spectrogram with pitch contour overlaid}

\item{savePath}{if a valid path is specified, the plot is saved in this
folder (defaults to NA)}

\item{plot_spec_pars}{a list of graphical parameters passed on to
\code{\link{spec}}. Set to \code{NULL} or \code{NA} to suppress plotting
the spectrogram}

\item{plot_pitch_pars}{a list of graphical parameters for displaying the
final pitch contour. Set to \code{NULL} or \code{NA} to suppress}

\item{plot_pitchCands_pars}{a list of graphical parameters for displaying
individual pitch candidates. Set to \code{NULL} or \code{NA} to suppress}

\item{summary}{if TRUE, summarizes acoustics per file}

\item{verbose}{if TRUE, reports progress and estimated time left}
}
\value{
If \code{summary} is TRUE, returns a dataframe with one row per audio
  file. If \code{summary} is FALSE, returns a list of detailed descriptives.
}
\description{
Acoustic analysis of all .wav files in a folder.
}
\examples{
\dontrun{
# download 260 sounds from Anikin & Persson (2017)
# http://cogsci.se/personal/results/
# 01_anikin-persson_2016_naturalistics-non-linguistic-vocalizations/260sounds_wav.zip
# unzip them into a folder, say '~/Downloads/temp'
myfolder = '~/Downloads/temp'  # 260 .wav files live here
s = analyzeFolder(myfolder, postprocess = 'slow', verbose = TRUE)

# Check accuracy: import manually verified pitch values (our "key")
key = pitch_manual  # a vector of 260 floats
trial = s$pitch_median
cor(key, trial, use = 'pairwise.complete.obs')
plot(log(key), log(trial))
abline(a=0, b=1, col='red')
}
}
