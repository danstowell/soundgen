% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/analyze.R
\name{analyzeFolder}
\alias{analyzeFolder}
\title{Analyze sound}
\usage{
analyzeFolder(myfolder, samplingRate = NULL, silence = 0.04,
  entropy_threshold = 0.6, windowLength = 50, wn = "gaussian",
  step = 25, zp = 0, zpCep = 2^13, pitch_floor = 75,
  pitch_ceiling = 3500, max_pitch_cands = 4,
  voiced_threshold_autocor = 0.75, voiced_threshold_cep = 0.45,
  voiced_threshold_spec = 0.5, specPitchThreshold_nullNA = 0.5,
  slope_spec = 0.1, width_spec = 150, pitchSpec_only_peak_weight = 0.51,
  prior_mean = HzToSemitones(300), prior_sd = 6, cutoff_dom = 6000,
  dom_threshold = 0.1, shortest_syl = 20, shortest_pause = 60,
  interpolWindow = 3, interpolTolerance = 0.3, interpolCert = 0.3,
  postprocess = c("none", "fast", "slow")[2], control_anneal = list(maxit =
  5000, temp = 1000), certWeight = 0.5, snake_step = 0.05,
  snake_plot = FALSE, smooth_idx = 1, smooth_vars = c("pitch", "dom"),
  plot = TRUE, savePath = NA, contrast = 0.2, brightness = 0,
  ylim = c(0, 5), summary = TRUE, verbose = TRUE)
}
\arguments{
\item{myfolder}{full path to target folder}

\item{samplingRate}{sampling rate of \code{x} (only needed if
\code{x} is a numeric vector, rather than a .wav file)}

\item{silence}{(0 to 1) frames with mean abs amplitude below silence
threshold are not analyzed. NB: this number is dynamically updated: the
actual silence threshold may be higher depending on the quietest frame, but
it will never be lower than this specified number.}

\item{entropy_threshold}{frames with entropy above \code{entropy_threshold}
are not analyzed (assumed to be just noise)}

\item{windowLength}{length of fft window (ms)}

\item{wn}{window type: gaussian, hanning, hamming, bartlett, rectangular, blackman, flattop}

\item{step}{fft step (ms)}

\item{zp}{zero padding (points)}

\item{zpCep}{zero-padding of the spectrum used for cepstral pitch detection
(points). Improves the precision of cepstral pitch detection quite
noticeably.}

\item{pitch_floor}{bounds for pitch candidates (Hz)}

\item{pitch_ceiling}{bounds for pitch candidates (Hz)}

\item{max_pitch_cands}{maximum number of pitch candidates to return. NB: only
one dom and one pitchCep is returned, so the remaining candidates come from
the autocorrelation and spectral pitch candidates.}

\item{voiced_threshold_autocor}{(0
to 1) separate thresholds for detecting pitch candidates with three
different methods: autocorrelation, cepstrum, and BaNa algorithm (see
Details). Note that HNR is still calculated for frames considered to be
unvoiced.}

\item{voiced_threshold_cep}{(0
to 1) separate thresholds for detecting pitch candidates with three
different methods: autocorrelation, cepstrum, and BaNa algorithm (see
Details). Note that HNR is still calculated for frames considered to be
unvoiced.}

\item{voiced_threshold_spec}{(0
to 1) separate thresholds for detecting pitch candidates with three
different methods: autocorrelation, cepstrum, and BaNa algorithm (see
Details). Note that HNR is still calculated for frames considered to be
unvoiced.}

\item{specPitchThreshold_nullNA}{when looking for putative
harmonics in the spectrum, the threshold for peak detection is calculated as
\code{specPitchThreshold_nullNA * (1 - HNR * slope_spec)}. For noisy sounds the
threshold is high to avoid false sumharmonics, while for tonal sounds it is low
to catch weak harmonics (BaNa - spectral pitch tracking)}

\item{slope_spec}{when looking for putative
harmonics in the spectrum, the threshold for peak detection is calculated as
\code{specPitchThreshold_nullNA * (1 - HNR * slope_spec)}. For noisy sounds the
threshold is high to avoid false sumharmonics, while for tonal sounds it is low
to catch weak harmonics (BaNa - spectral pitch tracking)}

\item{width_spec}{the width of window for detecting peaks in the spectrum
(BaNa - spectral pitch tracking)}

\item{pitchSpec_only_peak_weight}{(0 to 1) if only one pitchSpec candidate is
found, its weight (certainty) is taken to be
\code{pitchSpec_only_peak_weight}. This mainly has implications for how
much we trust the BaNa estimate vs. the autocorrelation estimate of f0.}

\item{prior_mean}{specifies the mean and sd of gamma distribution
describing our prior knowledge about the most likely pitch values for this
file. NB: prior values are specified in semitones above C0, and prior
densities are calculated on the musical scale, not in Hz! Ex.:
\code{prior_mean = HzToSemitones(300), prior_sd = 6} gives a prior with
mean = 300 Hz and SD of 6 semitones (half an octave)}

\item{prior_sd}{specifies the mean and sd of gamma distribution
describing our prior knowledge about the most likely pitch values for this
file. NB: prior values are specified in semitones above C0, and prior
densities are calculated on the musical scale, not in Hz! Ex.:
\code{prior_mean = HzToSemitones(300), prior_sd = 6} gives a prior with
mean = 300 Hz and SD of 6 semitones (half an octave)}

\item{cutoff_dom}{do not consider frequencies above cutoff_dom when
calculating the lowest dominant frequency band (recommended if the original
sampling rate varies across different analyzed audio files)}

\item{dom_threshold}{(0 to 1) to find the lowest dominant frequency band, we
do short-term FFT and take the lowest frequency with amplitude at least
dom_threshold}

\item{shortest_syl}{the smallest length of a voiced segment (ms) that
constitutes a syllable (shorter segments will be replaced by NA as if
unvoiced)}

\item{shortest_pause}{the smallest gap between voiced syllables (ms) that
means they shouldn't be merged into one voiced syllable}

\item{interpolWindow}{control the behavior of
interpolation algorithm when post-processing pitch candidates. See
\code{\link{pathfinder}} for details.}

\item{interpolTolerance}{control the behavior of
interpolation algorithm when post-processing pitch candidates. See
\code{\link{pathfinder}} for details.}

\item{interpolCert}{control the behavior of
interpolation algorithm when post-processing pitch candidates. See
\code{\link{pathfinder}} for details.}

\item{postprocess}{method of postprocessing pitch candidates to find the
optimal pitch contour: 'slow' for annealing, 'fast' for a simple heuristic,
'none' for none. See \code{\link{pathfinder}} for details.}

\item{control_anneal}{a list of control parameters for post-processing of
pitch contour with SANN algorithm of \code{\link[stats]{optim}}. This is
only relevant if \code{postprocess} is 'slow'}

\item{certWeight}{(0 to 1) in pitch postprocessing, specifies how much we
prioritize the certainty of pitch candidates vs. pitch jumps / the internal
tension of the resulting pitch curve. High certWeight: we mostly pay
attention to our certainty in particular pitch candidates; low certWeight:
we are more concerned with avoiding rapid pitch fluctuations in our
contour.}

\item{snake_step}{if \code{snake_step} is a positive number, the optimized
path through pitch candidates is further processed to minimize the elastic
force acting on pitch contour. Note that this imposes some smoothing and
thus creates pitch values that were not among candidates. The exact value
of \code{snake_step} controls the speed of snake adaptation.}

\item{snake_plot}{if TRUE, plots the snake (pitch postprocessing)}

\item{smooth_idx}{if \code{smooth_idx} is a positive number,
contours of the variables in \code{smooth_vars} are smoothed using a
customized version of median smoothing. Modifies only the values that
deviate considerably from the moving median and preserves all other values
(so this is a bit different from applying a moving median or kernel
smoothing). \code{smooth_idx} controls both the tolerated deviance and the
size of the window for calculating a moving median. \code{smooth_idx} of 1
corresponds to a window of ~100 ms and tolerated deviation of ~4 semitones.}

\item{smooth_vars}{if \code{smooth_idx} is a positive number,
contours of the variables in \code{smooth_vars} are smoothed using a
customized version of median smoothing. Modifies only the values that
deviate considerably from the moving median and preserves all other values
(so this is a bit different from applying a moving median or kernel
smoothing). \code{smooth_idx} controls both the tolerated deviance and the
size of the window for calculating a moving median. \code{smooth_idx} of 1
corresponds to a window of ~100 ms and tolerated deviation of ~4 semitones.}

\item{plot}{if TRUE, produces a spectrogram with pitch contour overlaid}

\item{savePath}{if a valid path is specified, the plot is saved in this
folder (defaults to NA)}

\item{summary}{if TRUE, summarizes acoustics per file}

\item{verbose}{if TRUE, reports progress and estimated time left}
}
\value{
If \code{summary} is TRUE, returns a dataframe with one row per audio
  file. If \code{summary} is FALSE, returns a list of detailed descriptives.
}
\description{
Acoustic analysis of all .wav files in a folder.
}
\examples{
\dontrun{
# download 260 sounds from Anikin & Persson (2017)
# http://cogsci.se/personal/results/
# 01_anikin-persson_2016_naturalistics-non-linguistic-vocalizations/260sounds_wav.zip
# unzip them into a folder, say '~/Downloads/temp'
myfolder = '~/Downloads/temp'  # 260 .wav files live here
s = analyzeFolder(myfolder, postprocess = 'slow', verbose = TRUE)

# Check accuracy: import manually verified pitch values (our "key")
key = pitch_manual  # a vector of 260 floats
trial = s$pitch_median
cor(key, trial, use = 'pairwise.complete.obs')
plot(log(key), log(trial))
abline(a=0, b=1, col='red')
}
}
