% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/segment.R
\name{optimizeSegment}
\alias{optimizeSegment}
\title{Optimize segmentation}
\usage{
optimizeSegment(myfolder, key, pars_to_optimize = list(c("shortest_syl",
  "shortest_pause", "syl_to_global_mean"), c("interburst_min_scale",
  "peak_to_global_max", "peak_to_trough"), c("smooth_ms",
  "smooth_overlap"))[[1]], pars_bounds = NULL,
  fitness_measure = c("nSyllables", "nBursts")[2], nIter = 10,
  wiggle_init = 0.2, control = list(maxit = 50, reltol = 0.01, trace = 0))
}
\arguments{
\item{myfolder}{path to where the .wav files live}

\item{key}{a vector containing the "correct" number of syllables in each file}

\item{pars_to_optimize}{names of arguments of \code{\link{segmentFolder}}
that should be optimized}

\item{pars_bounds}{a list setting the lower and upper boundaries for possible values of optimized parameters. For ex., if we optimize \code{smooth_ms} and \code{smooth_overlap}, reasonable pars_bounds might be list(low = c(5, 0), high = c(500, 95))}

\item{fitness_measure}{are we interested in optimizing the count of syllables
(\code{nSyllables}) or bursts (\code{nBursts})?}

\item{nIter}{repeat the optimization several times to check convergence}

\item{wiggle_init}{each optimization begins with a random seed, and
\code{wiggle_init} specifies the SD of normal distribution used to generate
random deviation of initial values from the defaults}

\item{control}{a list of control parameters passed on to
\code{\link[stats]{optim}}. The method used is "Nelder-Mead"}
}
\value{
Returns a matrix with one row per iteration, containing Pearson's
  correlation between the key and \code{fitness_measure} in the first column
  and the best values of each of the optimized parameters in the remaining
  columns.
}
\description{
Attemps to optimize the parameters of \code{\link{segmentFolder}} by
comparing the results with manual counting. This assumes that there is some
"key" - a manually annotated collection of audio files. This optimization
function just counts the number of bursts or syllables, so the key should be
a vector of counts per file. For other purposes, you may want to adapt the
optimization function so that the key specifies the exact timing of
syllables, their median length, interburst interval, or any other
characteristic that you want to optimize for. The general idea remains the
same, however: we want to tune the parameters of segmentation to fit our type
of audio and research priorities. The default settings of
\code{\link{segmentFolder}} are optimized for human non-linguistic
vocalizations.
}
\details{
If your sounds are very different from human non-linguistic vocalizations,
you may want to change the default values of arguments to
\code{\link{segmentFolder}} to speed up convergence. Also note that the
parameters are forced to be non-negative, but this may not be enough to
prevent occasional crashing, e.g. when optimizing smoothing parameters. Adapt
the code to enforce suitable constraints, depending on your data.
}
\examples{
\dontrun{
# download 260 sounds from Anikin & Persson (2017)
# http://cogsci.se/personal/results/
# 01_anikin-persson_2016_naturalistics-non-linguistic-vocalizations/260sounds_wav.zip
# unzip them into a folder, say '~/Downloads/temp'
myfolder = '~/Downloads/temp'  # 260 .wav files live here
# import manual counts of syllables in 260 sounds from Anikin & Persson (2017) (our "key")
key = segment_manual  # a vector of 260 integers

# run optimization loop several times with random initial values to check convergence
# NB: with 260 sounds and maxit = 50, this can take ~20 min per iteration!
res = optimizeSegment(myfolder = myfolder, key = key,
  pars_to_optimize = c('shortest_syl', 'shortest_pause', 'syl_to_global_mean'),
  fitness_measure = 'nSyllables',
  nIter = 2, control = list(maxit = 50, reltol = .01, trace = 0))

# examine the results
print(res)
for (c in 2:ncol(res)) {
  plot(res[, c], res[, 1], main = colnames(res)[c])
}
pars = as.list(res[1, 2:ncol(res)])  # top candidate (best pars)
s = do.call(segmentFolder, c(myfolder, pars))  # segment with best pars
cor(key, as.numeric(s[, fitness_measure]))
boxplot(as.numeric(s[, fitness_measure]) ~ as.integer(key), xlab='key')
abline(a=0, b=1, col='red')
}
}
